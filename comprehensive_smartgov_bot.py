#!/usr/bin/env python3
"""
Comprehensive Sikkim SmartGov Assistant Bot
"""
import asyncio
import json
import logging
import pandas as pd
import threading
import sys
import os
import aiohttp
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters
from config import Config
from datetime import datetime
import time
import random
from typing import Dict, Tuple

# Force UTF-8 encoding for Windows
if sys.platform == 'win32':
    os.system('chcp 65001')

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('bot.log', encoding='utf-8', mode='a')
    ]
)
logger = logging.getLogger(__name__)

class SmartGovAssistantBot:
    def __init__(self):
        """Initialize bot with configuration"""
        # Load configuration
        self.BOT_TOKEN = Config.BOT_TOKEN
        
        # Initialize states with thread-safe locks
        self.user_states = {}
        self.user_languages = {}
        self._state_lock = threading.RLock()
        
        # Load workflow data
        self._load_workflow_data()
        
        # Initialize multilingual responses
        self._initialize_responses()
        
        # Initialize aiohttp session for LLM calls
        self._session = None
        
        logger.info("ЁЯФТ MULTI-USER SUPPORT: Thread-safe state management initialized")

    def _load_workflow_data(self):
        """Load all required data files"""
        try:
            # Load emergency services data
            with open('data/emergency_services_text_responses.json', 'r', encoding='utf-8') as f:
                self.emergency_data = json.load(f)
            
            # Load other CSV data
            self.homestay_df = pd.read_csv('data/homestays_by_place.csv')
            self.csc_df = pd.read_csv('data/csc_contacts.csv')
            self.status_df = pd.read_csv('data/status.csv')
            
            logger.info("ЁЯУЪ Data files loaded successfully")
        except Exception as e:
            logger.error(f"тЭМ Error loading data files: {str(e)}")
            raise

    def _initialize_responses(self):
        """Initialize multilingual response templates"""
        self.responses = {
            'english': {
                'welcome': "Welcome to SmartGov Assistant! How can I help you today?",
                'error': "Sorry, I encountered an error. Please try again.",
                'unknown': "I'm not sure what you're asking for. Here are the available services:",
                'processing': "Processing your request...",
                'success': "Your request has been processed successfully.",
                'cancelled': "Operation cancelled. How else can I help you?",
                'emergency_ambulance': "ЁЯЪС *Ambulance Emergency*\nDial: 102 or 108\nControl Room: 03592-202033",
                'emergency_police': "ЁЯСо *Police Emergency*\nDial: 100\nControl Room: 03592-202022",
                'emergency_fire': "ЁЯЪТ *Fire Emergency*\nDial: 101\nControl Room: 03592-202099",
                'emergency_suicide': "ЁЯТн *Suicide Prevention Helpline*\nDial: 9152987821",
                'emergency_women': "ЁЯСй *Women Helpline*\nDial: 1091\nState Commission: 03592-205607",
                'ex_gratia_intro': "You may be eligible if you've suffered losses due to:\nтАв Heavy rainfall, floods, or landslides\nтАв Earthquakes or other natural calamities\nтАв Crop damage from hailstorms\nтАв House damage from natural disasters\nтАв Loss of livestock\n\nWould you like to proceed with the application?",
                'ex_gratia_form': "Please enter your full name:",
                'ex_gratia_father': "What is your father's name?",
                'ex_gratia_village': "Which village are you from?",
                'ex_gratia_contact': "What is your contact number? (10 digits)",
                'ex_gratia_ward': "What is your Ward number or name?",
                'ex_gratia_gpu': "Which Gram Panchayat Unit (GPU) are you under?",
                'ex_gratia_khatiyan': "What is your Khatiyan Number? (Land record number)",
                'ex_gratia_plot': "What is your Plot Number?",
                'ex_gratia_damage': "Please provide a detailed description of the damage:",
                'certificate_info': "To apply for services through the Sikkim SSO portal:\n1. Register and create an account on the Sikkim SSO portal\n2. Log in using your Sikkim SSO credentials\n3. Navigate to the desired service\n4. Fill out the application form\n5. Upload necessary documents\n6. Track your application status online\n\nWould you like to apply through a CSC operator or Single Window operator?",
                'other_emergency': "ЁЯЪи Other Emergency Services",
                'back_main_menu': "ЁЯФЩ Back to Main Menu"
            },
            'hindi': {
                'welcome': "рд╕реНрдорд╛рд░реНрдЯрдЧрд╡ рд╕рд╣рд╛рдпрдХ рдореЗрдВ рдЖрдкрдХрд╛ рд╕реНрд╡рд╛рдЧрдд рд╣реИ! рдореИрдВ рдЖрдкрдХреА рдХреИрд╕реЗ рдорджрдж рдХрд░ рд╕рдХрддрд╛ рд╣реВрдВ?",
                'error': "рдХреНрд╖рдорд╛ рдХрд░реЗрдВ, рдХреЛрдИ рддреНрд░реБрдЯрд┐ рд╣реБрдИред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВред",
                'unknown': "рдореБрдЭреЗ рд╕рдордЭ рдирд╣реАрдВ рдЖрдпрд╛ред рдпрд╣рд╛рдБ рдЙрдкрд▓рдмреНрдз рд╕реЗрд╡рд╛рдПрдВ рд╣реИрдВ:",
                'processing': "рдЖрдкрдХрд╛ рдЕрдиреБрд░реЛрдз рдкреНрд░реЛрд╕реЗрд╕ рдХрд┐рдпрд╛ рдЬрд╛ рд░рд╣рд╛ рд╣реИ...",
                'success': "рдЖрдкрдХрд╛ рдЕрдиреБрд░реЛрдз рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдкреНрд░реЛрд╕реЗрд╕ рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИред",
                'cancelled': "рдкреНрд░рдХреНрд░рд┐рдпрд╛ рд░рджреНрдж рдХрд░ рджреА рдЧрдИред рдореИрдВ рдФрд░ рдХреИрд╕реЗ рдорджрдж рдХрд░ рд╕рдХрддрд╛ рд╣реВрдВ?",
                'emergency_ambulance': "ЁЯЪС *рдПрдореНрдмреБрд▓реЗрдВрд╕ рдЗрдорд░рдЬреЗрдВрд╕реА*\nрдбрд╛рдпрд▓ рдХрд░реЗрдВ: 102 рдпрд╛ 108\nрдХрдВрдЯреНрд░реЛрд▓ рд░реВрдо: 03592-202033",
                'emergency_police': "ЁЯСо *рдкреБрд▓рд┐рд╕ рдЗрдорд░рдЬреЗрдВрд╕реА*\nрдбрд╛рдпрд▓ рдХрд░реЗрдВ: 100\nрдХрдВрдЯреНрд░реЛрд▓ рд░реВрдо: 03592-202022",
                'emergency_fire': "ЁЯЪТ *рдЕрдЧреНрдирд┐рд╢рдорди рдЗрдорд░рдЬреЗрдВрд╕реА*\nрдбрд╛рдпрд▓ рдХрд░реЗрдВ: 101\nрдХрдВрдЯреНрд░реЛрд▓ рд░реВрдо: 03592-202099",
                'emergency_suicide': "ЁЯТн *рдЖрддреНрдорд╣рддреНрдпрд╛ рд░реЛрдХрдерд╛рдо рд╣реЗрд▓реНрдкрд▓рд╛рдЗрди*\nрдбрд╛рдпрд▓ рдХрд░реЗрдВ: 9152987821",
                'emergency_women': "ЁЯСй *рдорд╣рд┐рд▓рд╛ рд╣реЗрд▓реНрдкрд▓рд╛рдЗрди*\nрдбрд╛рдпрд▓ рдХрд░реЗрдВ: 1091\nрд░рд╛рдЬреНрдп рдЖрдпреЛрдЧ: 03592-205607",
                'ex_gratia_intro': "рдЖрдк рдкрд╛рддреНрд░ рд╣реЛ рд╕рдХрддреЗ рд╣реИрдВ рдпрджрд┐ рдЖрдкрдХреЛ рдирд┐рдореНрдирд▓рд┐рдЦрд┐рдд рдХрд╛рд░рдгреЛрдВ рд╕реЗ рдиреБрдХрд╕рд╛рди рд╣реБрдЖ рд╣реИ:\nтАв рднрд╛рд░реА рдмрд╛рд░рд┐рд╢, рдмрд╛рдврд╝, рдпрд╛ рднреВрд╕реНрдЦрд▓рди\nтАв рднреВрдХрдВрдк рдпрд╛ рдЕрдиреНрдп рдкреНрд░рд╛рдХреГрддрд┐рдХ рдЖрдкрджрд╛рдПрдВ\nтАв рдУрд▓рд╛рд╡реГрд╖реНрдЯрд┐ рд╕реЗ рдлрд╕рд▓ рдХреА рдХреНрд╖рддрд┐\nтАв рдкреНрд░рд╛рдХреГрддрд┐рдХ рдЖрдкрджрд╛рдУрдВ рд╕реЗ рдШрд░ рдХреА рдХреНрд╖рддрд┐\nтАв рдкрд╢реБрдУрдВ рдХреА рд╣рд╛рдирд┐\n\nрдХреНрдпрд╛ рдЖрдк рдЖрд╡реЗрджрди рдХреЗ рд╕рд╛рде рдЖрдЧреЗ рдмрдврд╝рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ?",
                'ex_gratia_form': "рдХреГрдкрдпрд╛ рдЕрдкрдирд╛ рдкреВрд░рд╛ рдирд╛рдо рджрд░реНрдЬ рдХрд░реЗрдВ:",
                'ex_gratia_father': "рдЖрдкрдХреЗ рдкрд┐рддрд╛ рдХрд╛ рдирд╛рдо рдХреНрдпрд╛ рд╣реИ?",
                'ex_gratia_village': "рдЖрдк рдХрд┐рд╕ рдЧрд╛рдБрд╡ рд╕реЗ рд╣реИрдВ?",
                'ex_gratia_contact': "рдЖрдкрдХрд╛ рд╕рдВрдкрд░реНрдХ рдирдВрдмрд░ рдХреНрдпрд╛ рд╣реИ? (10 рдЕрдВрдХ)",
                'ex_gratia_ward': "рдЖрдкрдХрд╛ рд╡рд╛рд░реНрдб рдирдВрдмрд░ рдпрд╛ рдирд╛рдо рдХреНрдпрд╛ рд╣реИ?",
                'ex_gratia_gpu': "рдЖрдк рдХрд┐рд╕ рдЧреНрд░рд╛рдо рдкрдВрдЪрд╛рдпрдд рдЗрдХрд╛рдИ (GPU) рдХреЗ рдЕрдВрддрд░реНрдЧрдд рд╣реИрдВ?",
                'ex_gratia_khatiyan': "рдЖрдкрдХрд╛ рдЦрддрд┐рдпрд╛рди рдирдВрдмрд░ рдХреНрдпрд╛ рд╣реИ? (рдЬрдореАрди рдХрд╛ рд░рд┐рдХреЙрд░реНрдб рдирдВрдмрд░)",
                'ex_gratia_plot': "рдЖрдкрдХрд╛ рдкреНрд▓реЙрдЯ рдирдВрдмрд░ рдХреНрдпрд╛ рд╣реИ?",
                'ex_gratia_damage': "рдХреГрдкрдпрд╛ рдХреНрд╖рддрд┐ рдХрд╛ рд╡рд┐рд╕реНрддреГрдд рд╡рд┐рд╡рд░рдг рдкреНрд░рджрд╛рди рдХрд░реЗрдВ:",
                'certificate_info': "рд╕рд┐рдХреНрдХрд┐рдо SSO рдкреЛрд░реНрдЯрд▓ рдХреЗ рдорд╛рдзреНрдпрдо рд╕реЗ рд╕реЗрд╡рд╛рдУрдВ рдХреЗ рд▓рд┐рдП рдЖрд╡реЗрджрди рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП:\n1. рд╕рд┐рдХреНрдХрд┐рдо SSO рдкреЛрд░реНрдЯрд▓ рдкрд░ рдкрдВрдЬреАрдХрд░рдг рдХрд░реЗрдВ рдФрд░ рдЦрд╛рддрд╛ рдмрдирд╛рдПрдВ\n2. рдЕрдкрдиреЗ рд╕рд┐рдХреНрдХрд┐рдо SSO рдХреНрд░реЗрдбреЗрдВрд╢рд┐рдпрд▓реНрд╕ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдХреЗ рд▓реЙрдЧрд┐рди рдХрд░реЗрдВ\n3. рд╡рд╛рдВрдЫрд┐рдд рд╕реЗрд╡рд╛ рдкрд░ рдиреЗрд╡рд┐рдЧреЗрдЯ рдХрд░реЗрдВ\n4. рдЖрд╡реЗрджрди рдлреЙрд░реНрдо рднрд░реЗрдВ\n5. рдЖрд╡рд╢реНрдпрдХ рджрд╕реНрддрд╛рд╡реЗрдЬ рдЕрдкрд▓реЛрдб рдХрд░реЗрдВ\n6. рдЕрдкрдиреЗ рдЖрд╡реЗрджрди рдХреА рд╕реНрдерд┐рддрд┐ рдСрдирд▓рд╛рдЗрди рдЯреНрд░реИрдХ рдХрд░реЗрдВ\n\nрдХреНрдпрд╛ рдЖрдк CSC рдСрдкрд░реЗрдЯрд░ рдпрд╛ рд╕рд┐рдВрдЧрд▓ рд╡рд┐рдВрдбреЛ рдСрдкрд░реЗрдЯрд░ рдХреЗ рдорд╛рдзреНрдпрдо рд╕реЗ рдЖрд╡реЗрджрди рдХрд░рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ?",
                'other_emergency': "ЁЯЪи рдЕрдиреНрдп рдЖрдкрд╛рддрдХрд╛рд▓реАрди рд╕реЗрд╡рд╛рдПрдВ",
                'back_main_menu': "ЁЯФЩ рдореБрдЦреНрдп рдореЗрдиреВ рдкрд░ рд╡рд╛рдкрд╕"
            },
            'nepali': {
                'welcome': "рд╕реНрдорд╛рд░реНрдЯрдЧрдн рд╕рд╣рд╛рдпрдХрдорд╛ рд╕реНрд╡рд╛рдЧрдд рдЫ! рдо рддрдкрд╛рдИрдВрд▓рд╛рдИ рдХрд╕рд░реА рдорджреНрджрдд рдЧрд░реНрди рд╕рдХреНрдЫреБ?",
                'error': "рдорд╛рдл рдЧрд░реНрдиреБрд╣реЛрд╕реН, рддреНрд░реБрдЯрд┐ рднрдпреЛред рдХреГрдкрдпрд╛ рдкреБрди: рдкреНрд░рдпрд╛рд╕ рдЧрд░реНрдиреБрд╣реЛрд╕реНред",
                'unknown': "рдорд▓рд╛рдИ рдмреБрдЭреНрди рд╕рдХрд┐рдПрдиред рдпрд╣рд╛рдБ рдЙрдкрд▓рдмреНрдз рд╕реЗрд╡рд╛рд╣рд░реВ рдЫрдиреН:",
                'processing': "рддрдкрд╛рдИрдВрдХреЛ рдЕрдиреБрд░реЛрдз рдкреНрд░рд╢реЛрдзрди рдЧрд░рд┐рдБрджреИрдЫ...",
                'success': "рддрдкрд╛рдИрдВрдХреЛ рдЕрдиреБрд░реЛрдз рд╕рдлрд▓рддрд╛рдкреВрд░реНрд╡рдХ рдкреНрд░рд╢реЛрдзрди рдЧрд░рд┐рдпреЛред",
                'cancelled': "рдкреНрд░рдХреНрд░рд┐рдпрд╛ рд░рджреНрдж рдЧрд░рд┐рдпреЛред рдо рдЕрд░реБ рдХрд╕рд░реА рдорджреНрджрдд рдЧрд░реНрди рд╕рдХреНрдЫреБ?",
                'emergency_ambulance': "ЁЯЪС *рдПрдореНрдмреБрд▓реЗрдиреНрд╕ рдЖрдХрд╕реНрдорд┐рдХ*\nрдбрд╛рдпрд▓ рдЧрд░реНрдиреБрд╣реЛрд╕реН: 102 рд╡рд╛ 108\nрдХрдиреНрдЯреНрд░реЛрд▓ рд░реВрдо: 03592-202033",
                'emergency_police': "ЁЯСо *рдкреНрд░рд╣рд░реА рдЖрдХрд╕реНрдорд┐рдХ*\nрдбрд╛рдпрд▓ рдЧрд░реНрдиреБрд╣реЛрд╕реН: 100\nрдХрдиреНрдЯреНрд░реЛрд▓ рд░реВрдо: 03592-202022",
                'emergency_fire': "ЁЯЪТ *рдЕрдЧреНрдирд┐рд╢рдорди рдЖрдХрд╕реНрдорд┐рдХ*\nрдбрд╛рдпрд▓ рдЧрд░реНрдиреБрд╣реЛрд╕реН: 101\nрдХрдиреНрдЯреНрд░реЛрд▓ рд░реВрдо: 03592-202099",
                'emergency_suicide': "ЁЯТн *рдЖрддреНрдорд╣рддреНрдпрд╛ рд░реЛрдХрдерд╛рдо рд╣реЗрд▓реНрдкрд▓рд╛рдЗрди*\nрдбрд╛рдпрд▓ рдЧрд░реНрдиреБрд╣реЛрд╕реН: 9152987821",
                'emergency_women': "ЁЯСй *рдорд╣рд┐рд▓рд╛ рд╣реЗрд▓реНрдкрд▓рд╛рдЗрди*\nрдбрд╛рдпрд▓ рдЧрд░реНрдиреБрд╣реЛрд╕реН: 1091\nрд░рд╛рдЬреНрдп рдЖрдпреЛрдЧ: 03592-205607",
                'ex_gratia_intro': "рддрдкрд╛рдИрдВ рдкрд╛рддреНрд░ рд╣реБрди рд╕рдХреНрдиреБрд╣реБрдиреНрдЫ рдпрджрд┐ рддрдкрд╛рдИрдВрд▓рд╛рдИ рдирд┐рдореНрди рдХрд╛рд░рдгрд╣рд░реВрд▓реЗ рдХреНрд╖рддрд┐ рднрдПрдХреЛ рдЫ:\nтАв рднрд╛рд░реА рд╡рд░реНрд╖рд╛, рдмрд╛рдвреА, рд╡рд╛ рднреВрд╕реНрдЦрд▓рди\nтАв рднреВрдХрдореНрдк рд╡рд╛ рдЕрдиреНрдп рдкреНрд░рд╛рдХреГрддрд┐рдХ рдЖрдкрджрд╛рд╣рд░реВ\nтАв рдЕрд╕рд┐рдирд╛рд▓реЗ рдлрд╕рд▓рдХреЛ рдХреНрд╖рддрд┐\nтАв рдкреНрд░рд╛рдХреГрддрд┐рдХ рдЖрдкрджрд╛рд╣рд░реВрд▓реЗ рдШрд░рдХреЛ рдХреНрд╖рддрд┐\nтАв рдкрд╢реБрд╣рд░реВрдХреЛ рд╣рд╛рдирд┐\n\nрдХреЗ рддрдкрд╛рдИрдВ рдЖрд╡реЗрджрдирд╕рдБрдЧ рдЕрдЧрд╛рдбрд┐ рдмрдвреНрди рдЪрд╛рд╣рдиреБрд╣реБрдиреНрдЫ?",
                'ex_gratia_form': "рдХреГрдкрдпрд╛ рдЖрдлреНрдиреЛ рдкреВрд░рд╛ рдирд╛рдо рдкреНрд░рд╡рд┐рд╖реНрдЯ рдЧрд░реНрдиреБрд╣реЛрд╕реН:",
                'ex_gratia_father': "рддрдкрд╛рдИрдВрдХреЛ рдмреБрдмрд╛рдХреЛ рдирд╛рдо рдХреЗ рд╣реЛ?",
                'ex_gratia_village': "рддрдкрд╛рдИрдВ рдХреБрди рдЧрд╛рдЙрдБрдмрд╛рдЯ рд╣реБрдиреБрд╣реБрдиреНрдЫ?",
                'ex_gratia_contact': "рддрдкрд╛рдИрдВрдХреЛ рд╕рдореНрдкрд░реНрдХ рдирдореНрдмрд░ рдХреЗ рд╣реЛ? (10 рдЕрдВрдХ)",
                'ex_gratia_ward': "рддрдкрд╛рдИрдВрдХреЛ рд╡рд╛рд░реНрдб рдирдореНрдмрд░ рд╡рд╛ рдирд╛рдо рдХреЗ рд╣реЛ?",
                'ex_gratia_gpu': "рддрдкрд╛рдИрдВ рдХреБрди рдЧреНрд░рд╛рдо рдкрдВрдЪрд╛рдпрдд рдЗрдХрд╛рдИ (GPU) рдЕрдиреНрддрд░реНрдЧрдд рд╣реБрдиреБрд╣реБрдиреНрдЫ?",
                'ex_gratia_khatiyan': "рддрдкрд╛рдИрдВрдХреЛ рдЦрддрд┐рдпрд╛рди рдирдореНрдмрд░ рдХреЗ рд╣реЛ? (рдЬрдорд┐рдирдХреЛ рд░реЗрдХрд░реНрдб рдирдореНрдмрд░)",
                'ex_gratia_plot': "рддрдкрд╛рдИрдВрдХреЛ рдкреНрд▓рдЯ рдирдореНрдмрд░ рдХреЗ рд╣реЛ?",
                'ex_gratia_damage': "рдХреГрдкрдпрд╛ рдХреНрд╖рддрд┐рдХреЛ рд╡рд┐рд╕реНрддреГрдд рд╡рд┐рд╡рд░рдг рдкреНрд░рджрд╛рди рдЧрд░реНрдиреБрд╣реЛрд╕реН:",
                'certificate_info': "рд╕рд┐рдХреНрдХрд┐рдо SSO рдкреЛрд░реНрдЯрд▓ рдорд╛рд░реНрдлрдд рд╕реЗрд╡рд╛рд╣рд░реВрдХреЛ рд▓рд╛рдЧрд┐ рдЖрд╡реЗрджрди рдЧрд░реНрди:\n1. рд╕рд┐рдХреНрдХрд┐рдо SSO рдкреЛрд░реНрдЯрд▓рдорд╛ рджрд░реНрддрд╛ рдЧрд░реНрдиреБрд╣реЛрд╕реН рд░ рдЦрд╛рддрд╛ рд╕рд┐рд░реНрдЬрдирд╛ рдЧрд░реНрдиреБрд╣реЛрд╕реН\n2. рдЖрдлреНрдирд╛ рд╕рд┐рдХреНрдХрд┐рдо SSO рдХреНрд░реЗрдбреЗрдиреНрд╕рд┐рдпрд▓рд╣рд░реВ рдкреНрд░рдпреЛрдЧ рдЧрд░реЗрд░ рд▓рдЧрдЗрди рдЧрд░реНрдиреБрд╣реЛрд╕реН\n3. рдЗрдЪреНрдЫрд┐рдд рд╕реЗрд╡рд╛рдорд╛ рдиреЗрд╡рд┐рдЧреЗрдЯ рдЧрд░реНрдиреБрд╣реЛрд╕реН\n4. рдЖрд╡реЗрджрди рдлрд╛рд░рдо рднрд░реНрдиреБрд╣реЛрд╕реН\n5. рдЖрд╡рд╢реНрдпрдХ рдХрд╛рдЧрдЬрд╛рддрд╣рд░реВ рдЕрдкрд▓реЛрдб рдЧрд░реНрдиреБрд╣реЛрд╕реН\n6. рдЖрдлреНрдиреЛ рдЖрд╡реЗрджрдирдХреЛ рд╕реНрдерд┐рддрд┐ рдЕрдирд▓рд╛рдЗрди рдЯреНрд░реНрдпрд╛рдХ рдЧрд░реНрдиреБрд╣реЛрд╕реН\n\nрдХреЗ рддрдкрд╛рдИрдВ CSC рд╕рдЮреНрдЪрд╛рд▓рдХ рд╡рд╛ рд╕рд┐рдЩреНрдЧрд▓ рд╡рд┐рдиреНрдбреЛ рд╕рдЮреНрдЪрд╛рд▓рдХ рдорд╛рд░реНрдлрдд рдЖрд╡реЗрджрди рдЧрд░реНрди рдЪрд╛рд╣рдиреБрд╣реБрдиреНрдЫ?",
                'other_emergency': "ЁЯЪи рдЕрдиреНрдп рдЖрдХрд╕реНрдорд┐рдХ рд╕реЗрд╡рд╛рд╣рд░реВ",
                'back_main_menu': "ЁЯФЩ рдореБрдЦреНрдп рдореЗрдиреБрдорд╛ рдлрд┐рд░реНрддрд╛"
            }
        }

    def _get_user_state(self, user_id: int) -> dict:
        """Safely get user state with locking"""
        with self._state_lock:
            return self.user_states.get(user_id, {})

    def _set_user_state(self, user_id: int, state: dict):
        """Safely set user state with locking"""
        with self._state_lock:
            self.user_states[user_id] = state
            logger.info(f"ЁЯФТ STATE UPDATE: User {user_id} тЖТ {state}")

    def _clear_user_state(self, user_id: int):
        """Safely clear user state with locking"""
        with self._state_lock:
            if user_id in self.user_states:
                del self.user_states[user_id]
                logger.info(f"ЁЯз╣ STATE CLEARED: User {user_id}")

    def _get_user_language(self, user_id: int) -> str:
        """Get user's preferred language"""
        with self._state_lock:
            return self.user_languages.get(user_id, 'english')

    def _set_user_language(self, user_id: int, language: str):
        """Set user's preferred language"""
        with self._state_lock:
            self.user_languages[user_id] = language
            logger.info(f"ЁЯМР LANGUAGE SET: User {user_id} тЖТ {language}")

    async def _ensure_session(self):
        """Ensure aiohttp session exists"""
        if self._session is None:
            self._session = aiohttp.ClientSession()

    async def detect_language(self, text: str) -> str:
        """
        Detect language using Qwen LLM exclusively.
        """
        if not text or not text.strip():
            return 'english'
            
        try:
            await self._ensure_session()
            
            # Craft a prompt that leverages Qwen's multilingual capabilities
            prompt = f"""Analyze this text and determine if it's English, Hindi, or Nepali.
            
            Text to analyze: "{text}"
            
            CRITICAL DETECTION RULES:
            
            HINDI INDICATORS (Romanized):
            - Key words: mereko, mujhe, main, aap, tum, karna, chahiye, hai, hain
            - Grammar: verb + hain/hai (karna hain, chahiye hai)
            - Pronouns: mereko, mujhe, main, aap, tum
            - Question words: kya, kaise, kahan, kab, kyun, kaun
            
            NEPALI INDICATORS (Romanized):
            - Key words: malai, ma, tapai, timi, garna, chahincha, chha, hun
            - Grammar: verb + chha/chhan (garna chha, chahincha)
            - Pronouns: malai, ma, tapai, timi
            - Question words: ke, kasari, kahaan, kahile, kina, ko
            
            ENGLISH INDICATORS:
            - Pure English vocabulary and grammar
            - No Hindi/Nepali words mixed in
            
            DECISION RULES:
            1. If text contains "mereko", "mujhe", "karna hain", "chahiye" тЖТ HINDI
            2. If text contains "malai", "garna chha", "chahincha" тЖТ NEPALI
            3. If text is pure English тЖТ ENGLISH
            4. For mixed text, identify the dominant language based on grammar patterns
            
            Examples:
            - "Mereko ex gratia apply karna hain" тЖТ HINDI (mereko + karna hain)
            - "Malai certificate apply garna chha" тЖТ NEPALI (malai + garna chha)
            - "I want to apply for ex gratia" тЖТ ENGLISH (pure English)
            
            Respond with EXACTLY one word: english, hindi, or nepali"""
            
            logger.info(f"ЁЯФН [LLM] Language Detection Prompt: {prompt}")
            
            # Call Qwen through Ollama
            async with self._session.post(
                Config.OLLAMA_API_URL,
                json={
                    "model": Config.LLM_MODEL,
                    "prompt": prompt,
                    "stream": False,
                    "options": {
                        "temperature": 0.1,
                        "top_p": 0.9
                    }
                }
            ) as response:
                result = await response.json()
                detected_lang = result['response'].strip().lower()
                
                logger.info(f"ЁЯдЦ [LLM] Language Detection Response: {detected_lang}")
                
                # Validate response
                if detected_lang in ['english', 'hindi', 'nepali']:
                    logger.info(f"тЬЕ Language detected by Qwen: {detected_lang}")
                    return detected_lang
                else:
                    logger.warning(f"тЪая╕П Invalid language detection result: {detected_lang}, falling back to English")
                    return 'english'
                    
        except Exception as e:
            logger.error(f"тЭМ Language detection failed: {str(e)}")
            return 'english'  # Fallback to English on error

    async def message_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle incoming messages"""
        try:
            user_id = update.effective_user.id
            message_text = update.message.text
            
            logger.info(f"[MSG] User {user_id}: {message_text}")
            
            # Get current user state
            user_state = self._get_user_state(user_id)
            
            # Detect language for each message to handle language switching
            detected_lang = await self.detect_language(message_text)
            self._set_user_language(user_id, detected_lang)
            logger.info(f"[LANG] User {user_id} language detected: {detected_lang}")
            
            # Get user language
            user_lang = self._get_user_language(user_id)
            
            # If user is in a workflow, handle accordingly
            if user_state.get("workflow"):
                workflow = user_state.get("workflow")
                
                if workflow == "ex_gratia":
                    await self.handle_ex_gratia_workflow(update, context, message_text)
                elif workflow == "complaint":
                    await self.handle_complaint_workflow(update, context)
                elif workflow == "certificate":
                    await self.handle_certificate_workflow(update, context, message_text)
                elif workflow == "status_check":
                    await self.process_status_check(update, context)
                else:
                    # Unknown workflow, clear state and show main menu
                    self._clear_user_state(user_id)
                    await self.show_main_menu(update, context)
            else:
                # New conversation - detect intent and route
                logger.info(f"[INTENT] Processing new message: {message_text}")
                
                # Get intent using LLM
                intent = await self.get_intent_from_llm(message_text, user_lang)
                logger.info(f"[INTENT] Detected intent: {intent}")
                
                # Route based on intent
                if intent == "ex_gratia":
                    await self.handle_ex_gratia(update, context)
                elif intent == "check_status":
                    await self.handle_check_status(update, context)
                elif intent == "relief_norms":
                    await self.handle_relief_norms(update, context)
                elif intent == "emergency":
                    # Direct emergency response - don't show menu
                    await self.handle_emergency_direct(update, context, message_text)
                elif intent == "tourism":
                    await self.handle_tourism_menu(update, context)
                elif intent == "complaint":
                    await self.start_complaint_workflow(update, context)
                elif intent == "certificate":
                    await self.handle_certificate_info(update, context)
                elif intent == "csc":
                    await self.handle_csc_menu(update, context)
                else:
                    # Unknown intent, show main menu
                    await self.start(update, context)
            
        except Exception as e:
            logger.error(f"тЭМ Error in message handler: {str(e)}")
            user_lang = self._get_user_language(update.effective_user.id) if update.effective_user else 'english'
            await update.message.reply_text(
                self.responses[user_lang]['error']
            )

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        user = update.effective_user
        logger.info(f"[USER] New conversation started by user {user.id}")
        self._clear_user_state(user.id)
        
        welcome_text = """ЁЯПЫя╕П *Welcome to SmartGov Assistant* ЁЯПЫя╕П

Our services include:

1. *Book Homestay* ЁЯПб
   тАв Search by tourist destinations
   тАв View ratings and prices
   тАв Direct contact with owners

2. *Emergency Services* ЁЯЪи
   тАв Ambulance (102/108)
   тАв Police Helpline
   тАв Suicide Prevention
   тАв Health Helpline
   тАв Women Helpline
   тАв Fire Emergency
   тАв Report Disaster

3. *Report a Complaint* ЁЯУЭ
   тАв Register your grievance
   тАв Get complaint tracking ID
   тАв 24/7 monitoring

4. *Apply for Certificate* ЁЯТ╗
   тАв CSC operator assistance
   тАв Sikkim SSO portal link
   тАв Track application status

5. *Disaster Management* ЁЯЖШ
   тАв Apply for Ex-gratia
   тАв Check application status
   тАв View relief norms
   тАв Emergency contacts

Please select a service to continue:"""

        keyboard = [
            [InlineKeyboardButton("ЁЯПб Book Homestay", callback_data='tourism')],
            [InlineKeyboardButton("ЁЯЪи Emergency Services", callback_data='emergency')],
            [InlineKeyboardButton("ЁЯУЭ Report a Complaint", callback_data='complaint')],
            [InlineKeyboardButton("ЁЯТ╗ Apply for Certificate", callback_data='certificate')],
            [InlineKeyboardButton("ЁЯЖШ Disaster Management", callback_data='disaster')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Handle both regular messages and callbacks
        if update.callback_query:
            await update.callback_query.edit_message_text(welcome_text, reply_markup=reply_markup, parse_mode='Markdown')
        else:
            await update.message.reply_text(welcome_text, reply_markup=reply_markup, parse_mode='Markdown')

    async def detect_language_with_scoring(self, text: str) -> str:
        """Deprecated: Use detect_language instead."""
        return await self.detect_language(text)

    async def get_intent_from_llm(self, text: str, lang: str) -> str:
        """Get intent using Qwen LLM."""
        try:
            await self._ensure_session()
            
            prompt = f"""You are an intent classifier for SmartGov Assistant, a government services chatbot in Sikkim. Given the user's message, classify it into one of these intents:

Available intents:
- ex_gratia: User wants to apply for ex-gratia assistance or asks about compensation for damages
- check_status: User wants to check status of their application
- relief_norms: User asks about relief norms, policies, or eligibility criteria
- emergency: User needs emergency help (ambulance, police, fire)
- tourism: User wants tourism/homestay services
- complaint: User wants to file a complaint
- certificate: User wants to apply for certificates
- csc: User wants CSC (Common Service Center) services
- unknown: If none of the above match

Example messages for each intent:
- ex_gratia: "I want to apply for compensation", "My house was damaged in floods", "Need financial help for crop damage"
- check_status: "What's the status of my application?", "Track my ex-gratia request", "Any update on my claim?"
- relief_norms: "How much compensation will I get?", "What are the eligibility criteria?", "What documents are needed?"
- emergency: "Need ambulance", "Call police", "Fire emergency"
- tourism: "Book homestay", "Tourist places", "Accommodation"
- complaint: "File complaint", "Register grievance", "Report issue"
- certificate: "Apply for certificate", "Birth certificate", "Document"
- csc: "Find CSC", "CSC operator", "Common Service Center"

User message: {text}
Language: {lang}

Respond with ONLY one of the intent names listed above, nothing else."""

            logger.info(f"ЁЯОп [LLM] Intent Classification Prompt: {prompt}")

            async with self._session.post(
                Config.OLLAMA_API_URL,
                json={
                    "model": Config.LLM_MODEL,
                    "prompt": prompt,
                    "stream": False,
                    "options": {
                        "temperature": 0.1,
                        "top_p": 0.9
                    }
                }
            ) as response:
                result = await response.json()
                intent = result['response'].strip().lower()
                logger.info(f"ЁЯОп [LLM] Intent Classification Response: {intent}")
                
                # Validate intent
                valid_intents = ['ex_gratia', 'check_status', 'relief_norms', 'emergency', 'tourism', 'complaint', 'certificate', 'csc']
                return intent if intent in valid_intents else 'unknown'
                
        except Exception as e:
            logger.error(f"[LLM] Intent classification error: {str(e)}")
            return 'unknown'
        
    async def show_main_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show the main menu"""
        await self.start(update, context)

    async def callback_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle callback queries from inline keyboards"""
        query = update.callback_query
        user_id = update.effective_user.id
        data = query.data
        logger.info(f"[CALLBACK] Received from {user_id}: {data}")

        try:
            # Always answer the callback query first
            await query.answer()

            if data == "main_menu":
                self._clear_user_state(user_id)
                await self.start(update, context)
            
            elif data == "tourism":
                await self.handle_tourism_menu(update, context)
            
            elif data.startswith("place_"):
                await self.handle_place_selection(update, context)
            
            elif data == "disaster":
                await self.handle_disaster_menu(update, context)
            
            elif data == "relief_norms":
                await self.handle_relief_norms(update, context)
            
            elif data == "check_status":
                await self.handle_check_status(update, context)
            
            elif data == "ex_gratia":
                await self.handle_ex_gratia(update, context)
            
            elif data == "ex_gratia_start":
                await self.start_ex_gratia_workflow(update, context)
            
            elif data == "ex_gratia_submit":
                await self.submit_ex_gratia_application(update, context)
            
            elif data == "ex_gratia_edit":
                await self.handle_ex_gratia_edit(update, context)
            
            elif data == "ex_gratia_cancel":
                await self.cancel_ex_gratia_application(update, context)
            
            elif data.startswith("damage_type_"):
                damage_type = data.replace("damage_type_", "")
                await self.handle_damage_type_selection(update, context, damage_type)
            
            elif data == "emergency":
                await self.handle_emergency_menu(update, context)
            
            elif data.startswith("emergency_"):
                service = data.replace("emergency_", "")
                await self.handle_emergency_service(update, context, service)
            
            elif data == "csc":
                await self.handle_csc_menu(update, context)
            
            elif data.startswith("csc_"):
                district = data.replace("csc_", "")
                await self.handle_csc_selection(update, context, district)
            
            elif data == "certificate":
                await self.handle_certificate_info(update, context)
            
            elif data.startswith("cert_"):
                cert_type = data.replace("cert_", "")
                await self.handle_certificate_choice(update, context, cert_type)
            
            elif data == "certificate_csc":
                # Handle certificate CSC choice
                user_id = update.effective_user.id
                self._set_user_state(user_id, {"workflow": "certificate", "stage": "gpu"})
                await query.edit_message_text("Please enter your GPU (Gram Panchayat Unit):", parse_mode='Markdown')
            
            elif data == "certificate_sso":
                # Handle certificate SSO choice
                await query.edit_message_text(
                    "You can apply directly on the Sikkim SSO Portal: https://sso.sikkim.gov.in\n\n"
                    "ЁЯФЩ Back to Main Menu", 
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("ЁЯФЩ Back to Main Menu", callback_data="main_menu")]]),
                    parse_mode='Markdown'
                )
            
            elif data == "complaint":
                await self.start_complaint_workflow(update, context)
            
            else:
                logger.warning(f"Unhandled callback data: {data}")
                await query.message.reply_text("Sorry, I couldn't process that request.")

        except Exception as e:
            logger.error(f"Error in callback handler: {str(e)}")
            await query.message.reply_text("Sorry, an error occurred. Please try again.")

    # --- Disaster Management ---
    async def handle_disaster_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle disaster management menu"""
        keyboard = [
            [InlineKeyboardButton("ЁЯУЭ Apply for Ex-gratia", callback_data="ex_gratia")],
            [InlineKeyboardButton("ЁЯФН Check Application Status", callback_data="check_status")],
            [InlineKeyboardButton("тД╣я╕П View Relief Norms", callback_data="relief_norms")],
            [InlineKeyboardButton("ЁЯФЩ Back to Main Menu", callback_data="main_menu")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        text = """*Disaster Management Services* ЁЯЖШ

Please select an option:

1. Apply for Ex-gratia assistance
2. Check your application status
3. View disaster relief norms"""

        if update.callback_query:
            await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
        else:
            await update.message.reply_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    async def handle_relief_norms(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show disaster relief norms"""
        text = """*Disaster Relief Norms* тД╣я╕П

The Government of Sikkim provides relief assistance for:

1. House Damage
   тАв Fully Damaged: Up to тВ╣25,000
   тАв Severely Damaged: Up to тВ╣15,000
   тАв Partially Damaged: Up to тВ╣4,000

2. Crop Loss
   тАв Above 2 hectares: Up to тВ╣15,000
   тАв 1-2 hectares: Up to тВ╣10,000
   тАв Below 1 hectare: Up to тВ╣4,000

3. Livestock Loss
   тАв Large animals: Up to тВ╣15,000
   тАв Small animals: Up to тВ╣2,000

For more details, please visit your nearest District Administration office."""

        keyboard = [
            [InlineKeyboardButton("ЁЯУЭ Apply Now", callback_data="ex_gratia")],
            [InlineKeyboardButton("ЁЯФЩ Back to Disaster Menu", callback_data="disaster")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    async def handle_check_status(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle application status check"""
        user_id = update.effective_user.id
        self._set_user_state(user_id, {"workflow": "check_status"})
        
        text = """*Check Application Status* ЁЯФН

Please enter your Application ID:
(Format: EX2025XXXXXXX)"""

        keyboard = [[InlineKeyboardButton("ЁЯФЩ Cancel", callback_data="disaster")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    async def process_status_check(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Process application status check"""
        application_id = update.message.text.strip().upper()
        
        try:
            # Read status from CSV
            df = pd.read_csv('data/exgratia_applications.csv')
            application = df[df['ApplicationID'] == application_id].iloc[0]
            
            status_text = f"""*Application Status* ЁЯУЛ

Application ID: {application_id}
Name: {application['ApplicantName']}
Village: {application['Village']}
Status: Processing
Submission Date: {application['SubmissionTimestamp']}

Your application is being reviewed by the district administration."""
        except:
            status_text = """тЭМ *Application Not Found*

Please check the Application ID and try again.
If the problem persists, contact support."""

        keyboard = [[InlineKeyboardButton("ЁЯФЩ Back to Disaster Menu", callback_data="disaster")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(status_text, reply_markup=reply_markup, parse_mode='Markdown')
        
        # Clear the workflow state
        self._clear_user_state(update.effective_user.id)

    async def handle_ex_gratia(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle ex-gratia application"""
        user_id = update.effective_user.id
        user_lang = self._get_user_language(user_id)
        
        text = f"*Ex-Gratia Assistance* ЁЯУЭ\n\n{self.responses[user_lang]['ex_gratia_intro']}"

        keyboard = [
            [InlineKeyboardButton("тЬЕ Yes, Continue", callback_data="ex_gratia_start")],
            [InlineKeyboardButton("тЭМ No, Go Back", callback_data="disaster")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Handle both regular messages and callbacks
        if update.callback_query:
            await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
        else:
            await update.message.reply_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    # --- Ex-Gratia Application ---
    async def start_ex_gratia_workflow(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Start the ex-gratia application workflow"""
        user_id = update.effective_user.id
        user_lang = self._get_user_language(user_id)
        self._set_user_state(user_id, {"workflow": "ex_gratia", "step": "name"})
        
        text = f"*Ex-Gratia Application Form* ЁЯУЭ\n\n{self.responses[user_lang]['ex_gratia_form']}"
        
        keyboard = [[InlineKeyboardButton("ЁЯФЩ Cancel", callback_data="disaster")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Handle both regular messages and callbacks
        if update.callback_query:
            await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
        else:
            await update.message.reply_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    async def handle_ex_gratia_workflow(self, update: Update, context: ContextTypes.DEFAULT_TYPE, text: str):
        """Handle the ex-gratia application workflow"""
        user_id = update.effective_user.id
        user_lang = self._get_user_language(user_id)
        state = self._get_user_state(user_id)
        step = state.get("step")
        data = state.get("data", {})

        if step == "name":
            data["name"] = text
            state["step"] = "father_name"
            state["data"] = data
            self._set_user_state(user_id, state)
            await update.message.reply_text(self.responses[user_lang]['ex_gratia_father'], parse_mode='Markdown')

        elif step == "father_name":
            data["father_name"] = text
            state["step"] = "village"
            state["data"] = data
            self._set_user_state(user_id, state)
            await update.message.reply_text(self.responses[user_lang]['ex_gratia_village'], parse_mode='Markdown')

        elif step == "village":
            data["village"] = text
            state["step"] = "contact"
            state["data"] = data
            self._set_user_state(user_id, state)
            await update.message.reply_text(self.responses[user_lang]['ex_gratia_contact'], parse_mode='Markdown')

        elif step == "contact":
            if not text.isdigit() or len(text) != 10:
                await update.message.reply_text("Please enter a valid 10-digit mobile number.", parse_mode='Markdown')
                return
            
            data["contact"] = text
            state["step"] = "ward"
            state["data"] = data
            self._set_user_state(user_id, state)
            await update.message.reply_text(self.responses[user_lang]['ex_gratia_ward'], parse_mode='Markdown')

        elif step == "ward":
            data["ward"] = text
            state["step"] = "gpu"
            state["data"] = data
            self._set_user_state(user_id, state)
            await update.message.reply_text(self.responses[user_lang]['ex_gratia_gpu'], parse_mode='Markdown')

        elif step == "gpu":
            data["gpu"] = text
            state["step"] = "khatiyan"
            state["data"] = data
            self._set_user_state(user_id, state)
            await update.message.reply_text(self.responses[user_lang]['ex_gratia_khatiyan'], parse_mode='Markdown')

        elif step == "khatiyan":
            data["khatiyan_no"] = text
            state["step"] = "plot"
            state["data"] = data
            self._set_user_state(user_id, state)
            await update.message.reply_text(self.responses[user_lang]['ex_gratia_plot'], parse_mode='Markdown')

        elif step == "plot":
            data["plot_no"] = text
            state["step"] = "damage_type"
            state["data"] = data
            self._set_user_state(user_id, state)
            await self.show_damage_type_options(update, context)

        elif step == "damage_type":
            data["damage_type"] = text
            state["step"] = "damage_description"
            state["data"] = data
            self._set_user_state(user_id, state)
            await update.message.reply_text(self.responses[user_lang]['ex_gratia_damage'], parse_mode='Markdown')

        elif step == "damage_description":
            data["damage_description"] = text
            state["data"] = data
            self._set_user_state(user_id, state)
            await self.show_ex_gratia_confirmation(update, context, data)

        else:
            await update.message.reply_text(self.responses[user_lang]['error'], parse_mode='Markdown')
            self._clear_user_state(user_id)

    async def show_damage_type_options(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [InlineKeyboardButton("ЁЯПа House Damage (тВ╣4,000 - тВ╣25,000)", callback_data='damage_type_house')],
            [InlineKeyboardButton("ЁЯМ╛ Crop Loss (тВ╣4,000 - тВ╣15,000)", callback_data='damage_type_crop')],
            [InlineKeyboardButton("ЁЯРД Livestock Loss (тВ╣2,000 - тВ╣15,000)", callback_data='damage_type_livestock')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Handle both regular messages and callbacks
        if update.callback_query:
            await update.callback_query.edit_message_text("Please select the type of damage:", reply_markup=reply_markup, parse_mode='Markdown')
        else:
            await update.message.reply_text("Please select the type of damage:", reply_markup=reply_markup, parse_mode='Markdown')

    async def handle_damage_type_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE, damage_type: str):
        """Handle damage type selection in ex-gratia workflow"""
        user_id = update.effective_user.id
        state = self._get_user_state(user_id)
        data = state.get("data", {})
        
        damage_types = {
            'house': 'ЁЯПа House Damage',
            'crop': 'ЁЯМ╛ Crop Loss',
            'livestock': 'ЁЯРД Livestock Loss'
        }
        
        data['damage_type'] = damage_types[damage_type]
        state['step'] = 'damage_description'
        state['data'] = data
        self._set_user_state(user_id, state)
        
        text = f"""Selected: {damage_types[damage_type]}

Please provide detailed description of the damage:
(Include location, extent of damage, date of incident)"""

        await update.callback_query.edit_message_text(text, parse_mode='Markdown')

    async def show_ex_gratia_confirmation(self, update: Update, context: ContextTypes.DEFAULT_TYPE, data: dict):
        """Show confirmation of collected data before submission"""
        summary = """*Please Review Your Application* ЁЯУЛ

*Personal Details:*
ЁЯСд Name: {name}
ЁЯСитАНЁЯСж Father's Name: {father}
ЁЯУН Village: {village}
ЁЯУ▒ Contact: {contact}

*Land Details:*
ЁЯПШя╕П Ward: {ward}
ЁЯПЫя╕П GPU: {gpu}
ЁЯУД Khatiyan Number: {khatiyan}
ЁЯЧ║я╕П Plot Number: {plot}

*Damage Details:*
ЁЯП╖я╕П Type: {damage_type}
ЁЯУЭ Description: {damage}

Please verify all details carefully. Would you like to:""".format(
            name=data.get('name', 'N/A'),
            father=data.get('father_name', 'N/A'),
            village=data.get('village', 'N/A'),
            contact=data.get('contact', 'N/A'),
            ward=data.get('ward', 'N/A'),
            gpu=data.get('gpu', 'N/A'),
            khatiyan=data.get('khatiyan_no', 'N/A'),
            plot=data.get('plot_no', 'N/A'),
            damage_type=data.get('damage_type', 'N/A'),
            damage=data.get('damage_description', 'N/A')
        )
        
        keyboard = [
            [InlineKeyboardButton("тЬЕ Submit Application", callback_data='ex_gratia_submit')],
            [InlineKeyboardButton("тЬПя╕П Edit Details", callback_data='ex_gratia_edit')],
            [InlineKeyboardButton("тЭМ Cancel", callback_data='ex_gratia_cancel')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Handle both regular messages and callbacks
        if update.callback_query:
            await update.callback_query.edit_message_text(summary, reply_markup=reply_markup, parse_mode='Markdown')
        else:
            await update.message.reply_text(summary, reply_markup=reply_markup, parse_mode='Markdown')

    async def submit_ex_gratia_application(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Submit the ex-gratia application"""
        user_id = update.effective_user.id
        state = self._get_user_state(user_id)
        data = state.get("data", {})

        try:
            # Generate application ID
            now = datetime.now()
            app_id = f"EXG{now.strftime('%Y%m%d')}{random.randint(1000,9999)}"
            
            # Save to CSV
            df = pd.DataFrame([{
                'ApplicationID': app_id,
                'ApplicantName': data.get('name'),
                'FatherName': data.get('father_name'),
                'Village': data.get('village'),
                'Contact': data.get('contact'),
                'Ward': data.get('ward'),
                'GPU': data.get('gpu'),
                'KhatiyanNo': data.get('khatiyan_no'),
                'PlotNo': data.get('plot_no'),
                'DamageDescription': data.get('damage_description'),
                'SubmissionTimestamp': now.strftime('%Y-%m-%d %H:%M:%S'),
                'Status': 'Pending'
            }])
            
            df.to_csv('data/exgratia_applications.csv', mode='a', header=False, index=False)
            
            # Send confirmation
            confirmation = f"""тЬЕ *Application Submitted Successfully!*

ЁЯЖФ Application ID: {app_id}
ЁЯСд Name: {data.get('name')}

*Next Steps:*
1. Your data will be verified
2. Update in 7-10 days
3. SMS will be sent to your number

Support: +91-1234567890"""

            keyboard = [[InlineKeyboardButton("ЁЯФЩ Back to Disaster Management", callback_data="disaster")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            if update.callback_query:
                await update.callback_query.edit_message_text(confirmation, reply_markup=reply_markup, parse_mode='Markdown')
            else:
                await update.message.reply_text(confirmation, reply_markup=reply_markup, parse_mode='Markdown')
            
            # Clear user state
            self._clear_user_state(user_id)
            
        except Exception as e:
            logger.error(f"Error submitting application: {str(e)}")
            error_msg = "Sorry, there was an error submitting your application. Please try again."
            if update.callback_query:
                await update.callback_query.edit_message_text(error_msg, parse_mode='Markdown')
            else:
                await update.message.reply_text(error_msg, parse_mode='Markdown')

    async def cancel_ex_gratia_application(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        self._clear_user_state(user_id)
        await update.callback_query.edit_message_text("Your application has been cancelled.")
        await self.show_main_menu(update, context)

    async def handle_ex_gratia_edit(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle editing of ex-gratia application details"""
        keyboard = [
            [InlineKeyboardButton("ЁЯСд Name", callback_data="edit_name")],
            [InlineKeyboardButton("ЁЯСитАНЁЯСж Father's Name", callback_data="edit_father")],
            [InlineKeyboardButton("ЁЯУН Village", callback_data="edit_village")],
            [InlineKeyboardButton("ЁЯУ▒ Contact", callback_data="edit_contact")],
            [InlineKeyboardButton("ЁЯПШя╕П Ward", callback_data="edit_ward")],
            [InlineKeyboardButton("ЁЯПЫя╕П GPU", callback_data="edit_gpu")],
            [InlineKeyboardButton("ЁЯУД Khatiyan Number", callback_data="edit_khatiyan")],
            [InlineKeyboardButton("ЁЯЧ║я╕П Plot Number", callback_data="edit_plot")],
            [InlineKeyboardButton("ЁЯУЭ Damage Description", callback_data="edit_damage")],
            [InlineKeyboardButton("тЬЕ Done Editing", callback_data="edit_done")],
            [InlineKeyboardButton("тЭМ Cancel", callback_data="ex_gratia_cancel")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        text = """*Which information would you like to edit?* тЬПя╕П

Select the field you want to update:"""
        
        await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    # --- Emergency Services ---
    async def handle_emergency_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle emergency services menu"""
        keyboard = [
            [InlineKeyboardButton("ЁЯЪС Ambulance", callback_data="emergency_medical")],
            [InlineKeyboardButton("ЁЯСо Police Helpline", callback_data="emergency_police")],
            [InlineKeyboardButton("ЁЯТн Suicide Prevention", callback_data="emergency_suicide")],
            [InlineKeyboardButton("ЁЯПе Health Helpline", callback_data="emergency_health")],
            [InlineKeyboardButton("ЁЯСй Women Helpline", callback_data="emergency_women")],
            [InlineKeyboardButton("ЁЯЪТ Fire Emergency", callback_data="emergency_fire")],
            [InlineKeyboardButton("ЁЯЖШ Report Disaster", callback_data="emergency_disaster")],
            [InlineKeyboardButton("ЁЯФЩ Back to Main Menu", callback_data="main_menu")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        text = """*Emergency Services* ЁЯЪи

Select the type of emergency service you need:"""
        
        if update.callback_query:
            await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
        else:
            await update.message.reply_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    async def handle_emergency_direct(self, update: Update, context: ContextTypes.DEFAULT_TYPE, message_text: str):
        """Handle emergency requests directly without showing menu"""
        try:
            user_id = update.effective_user.id
            user_lang = self._get_user_language(user_id)
            message_lower = message_text.lower()
            
            # Determine which emergency service is needed
            if any(word in message_lower for word in ['ambulance', 'ambulance', 'medical', 'doctor', 'hospital']):
                service_type = 'ambulance'
                response_text = self.responses[user_lang]['emergency_ambulance']
            elif any(word in message_lower for word in ['police', 'police', 'thief', 'robbery', 'crime']):
                service_type = 'police'
                response_text = self.responses[user_lang]['emergency_police']
            elif any(word in message_lower for word in ['fire', 'fire', 'burning', 'blaze']):
                service_type = 'fire'
                response_text = self.responses[user_lang]['emergency_fire']
            elif any(word in message_lower for word in ['suicide', 'suicide', 'helpline']):
                service_type = 'suicide'
                response_text = self.responses[user_lang]['emergency_suicide']
            elif any(word in message_lower for word in ['women', 'women', 'harassment']):
                service_type = 'women'
                response_text = self.responses[user_lang]['emergency_women']
            else:
                # Default to ambulance for general emergency
                service_type = 'ambulance'
                response_text = self.responses[user_lang]['emergency_ambulance']
            
            keyboard = [
                [InlineKeyboardButton(self.responses[user_lang]['other_emergency'], callback_data="emergency")],
                [InlineKeyboardButton(self.responses[user_lang]['back_main_menu'], callback_data="main_menu")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(response_text, reply_markup=reply_markup, parse_mode='Markdown')
        except Exception as e:
            logger.error(f"Error handling emergency direct: {str(e)}")
            user_lang = self._get_user_language(update.effective_user.id) if update.effective_user else 'english'
            await update.message.reply_text(self.responses[user_lang]['error'])

    async def handle_emergency_service(self, update: Update, context: ContextTypes.DEFAULT_TYPE, service_type: str):
        """Handle specific emergency service selection"""
        query = update.callback_query
        
        if service_type in ['medical', 'disaster']:
            response_text = self.emergency_data[service_type]['english']
        else:
            # Default emergency numbers for other services
            response_text = {
                'police': "ЁЯСо *Police Emergency*\nDial: 100\nControl Room: 03592-202022",
                'fire': "ЁЯЪТ *Fire Emergency*\nDial: 101\nControl Room: 03592-202099",
                'women': "ЁЯСй *Women Helpline*\nDial: 1091\nState Commission: 03592-205607",
                'health': "ЁЯПе *Health Helpline*\nDial: 104\nToll Free: 1800-345-3049",
                'suicide': "ЁЯТн *Suicide Prevention Helpline*\nDial: 9152987821"
            }.get(service_type, "Please call 112 for any emergency assistance.")
        
        keyboard = [
            [InlineKeyboardButton("ЁЯФЩ Back to Emergency Services", callback_data="emergency")],
            [InlineKeyboardButton("ЁЯПа Back to Main Menu", callback_data="main_menu")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(response_text, reply_markup=reply_markup, parse_mode='Markdown')

    # --- Tourism & Homestays ---
    async def handle_tourism_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle homestay booking menu"""
        places = pd.read_csv('data/homestays_by_place.csv')['Place'].unique()
        keyboard = []
        for place in places:
            keyboard.append([InlineKeyboardButton(f"ЁЯПб {place}", callback_data=f"place_{place}")])
        keyboard.append([InlineKeyboardButton("ЁЯФЩ Back to Main Menu", callback_data="main_menu")])
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        text = """*Book a Homestay* ЁЯПб

Please select your destination:"""
        
        if update.callback_query:
            await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
        else:
            await update.message.reply_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    async def handle_place_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle specific place selection for homestays"""
        query = update.callback_query
        place = query.data.replace('place_', '')
        
        homestays = pd.read_csv('data/homestays_by_place.csv')
        place_homestays = homestays[homestays['Place'] == place]
        
        text = f"*Available Homestays in {place}* ЁЯПб\n\n"
        for _, row in place_homestays.iterrows():
            text += f"*{row['HomestayName']}*\n"
            text += f"тнР Rating: {row['Rating']}\n"
            text += f"ЁЯТ░ Price per night: тВ╣{row['PricePerNight']}\n"
            text += f"ЁЯУЮ Contact: {row['ContactNumber']}\n\n"
        
        keyboard = [
            [InlineKeyboardButton("ЁЯФН Search Another Place", callback_data="tourism")],
            [InlineKeyboardButton("ЁЯФЩ Back to Main Menu", callback_data="main_menu")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    # --- Common Service Centers ---
    async def handle_csc_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        keyboard = [
            [InlineKeyboardButton("Find Nearest CSC", callback_data='csc_find')],
            [InlineKeyboardButton("Apply for Certificate", callback_data='certificate')],
            [InlineKeyboardButton("Back to Main Menu", callback_data='main_menu')]
        ]
        text = """*Common Service Centers (CSC)* ЁЯТ╗

Please select an option:
1. Find nearest CSC
2. Apply for certificate
3. Return to main menu"""
        await update.callback_query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')

    async def handle_csc_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE, district: str):
        # This will be used for finding nearest CSC
        self._set_user_state(update.effective_user.id, {"workflow": "certificate", "stage": "gpu"}) # piggybacking on certificate flow for now
        await update.callback_query.edit_message_text("Please enter your GPU (Gram Panchayat Unit):", parse_mode='Markdown')

    async def handle_certificate_info(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle certificate services information"""
        user_id = update.effective_user.id
        user_lang = self._get_user_language(user_id)
        
        text = f"*Apply for Certificate through Sikkim SSO* ЁЯТ╗\n\n{self.responses[user_lang]['certificate_info']}"

        keyboard = [
            [InlineKeyboardButton("тЬЕ Yes, Connect with CSC", callback_data="certificate_csc")],
            [InlineKeyboardButton("ЁЯМР No, I'll use SSO Portal", callback_data="certificate_sso")],
            [InlineKeyboardButton("ЁЯФЩ Back to Main Menu", callback_data="main_menu")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if update.callback_query:
            await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
        else:
            await update.message.reply_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    async def handle_certificate_workflow(self, update: Update, context: ContextTypes.DEFAULT_TYPE, text: str):
        """Handle certificate application workflow"""
        user_id = update.effective_user.id
        state = self._get_user_state(user_id)
        if state.get("stage") == "gpu":
            gpu = text.strip().upper()
            csc_info = self.csc_df[self.csc_df['GPU'].str.upper() == gpu]
            if csc_info.empty:
                await update.message.reply_text("Sorry, no CSC operator found for your GPU.")
            else:
                info = csc_info.iloc[0]
                message = f"CSC Operator Details:\n\nName: {info['CSC_Operator_Name']}\nContact: {info['PhoneNumber']}\nTimings: {info['Timings']}"
                await update.message.reply_text(message)
            self._clear_user_state(user_id)

    async def handle_certificate_choice(self, update: Update, context: ContextTypes.DEFAULT_TYPE, choice: str):
        if choice == 'yes':
            self._set_user_state(update.effective_user.id, {"workflow": "certificate", "stage": "gpu"})
            await update.callback_query.edit_message_text("Please enter your GPU (Gram Panchayat Unit):", parse_mode='Markdown')
        else:
            await update.callback_query.edit_message_text("You can apply directly on the Sikkim SSO Portal: https://sso.sikkim.gov.in", parse_mode='Markdown')
        
    async def handle_certificate_workflow(self, update: Update, context: ContextTypes.DEFAULT_TYPE, text: str):
        user_id = update.effective_user.id
        state = self._get_user_state(user_id)
        if state.get("stage") == "gpu":
            gpu = text.strip().upper()
            csc_info = self.csc_df[self.csc_df['GPU'].str.upper() == gpu]
            if csc_info.empty:
                await update.message.reply_text("Sorry, no CSC operator found for your GPU.")
            else:
                info = csc_info.iloc[0]
                message = f"CSC Operator Details:\n\nName: {info['CSC_Operator_Name']}\nContact: {info['PhoneNumber']}\nTimings: {info['Timings']}"
                await update.message.reply_text(message)
            self._clear_user_state(user_id)

    # --- Complaint ---
    async def start_complaint_workflow(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Start the complaint registration workflow"""
        user_id = update.effective_user.id
        self._set_user_state(user_id, {"workflow": "complaint", "step": "name"})
        
        text = """*Report a Complaint/Grievance* ЁЯУЭ

Please enter your full name:"""
        
        keyboard = [[InlineKeyboardButton("ЁЯФЩ Cancel", callback_data="main_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        if update.callback_query:
            await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
        else:
            await update.message.reply_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    async def handle_complaint_workflow(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle the complaint workflow steps"""
        user_id = update.effective_user.id
        text = update.message.text
        state = self._get_user_state(user_id)
        step = state.get("step")
        
        if step == "name":
            state["name"] = text
            state["step"] = "mobile"
            self._set_user_state(user_id, state)
            await update.message.reply_text("Please enter your mobile number:", parse_mode='Markdown')
        
        elif step == "mobile":
            if not text.isdigit() or len(text) != 10:
                await update.message.reply_text("Please enter a valid 10-digit mobile number.", parse_mode='Markdown')
                return
            
            state["mobile"] = text
            state["step"] = "complaint"
            self._set_user_state(user_id, state)
            await update.message.reply_text("Please describe your complaint in detail:", parse_mode='Markdown')
        
        elif step == "complaint":
            # Generate complaint ID
            now = datetime.now()
            complaint_id = f"CMP{now.strftime('%Y%m%d')}{random.randint(100, 999)}"
            
            # Save complaint to CSV
            complaint_data = {
                'Complaint_ID': complaint_id,
                'Name': state.get('name'),
                'Mobile': state.get('mobile'),
                'Complaint': text,
                'Date': now.strftime('%Y-%m-%d %H:%M:%S'),
                'Status': 'Pending'
            }
            
            df = pd.DataFrame([complaint_data])
            df.to_csv('data/submission.csv', mode='a', header=False, index=False)
            
            # Send confirmation
            confirmation = f"""тЬЕ *Complaint Registered Successfully*

ЁЯЖФ Complaint ID: {complaint_id}
ЁЯСд Name: {state.get('name')}
ЁЯУ▒ Mobile: {state.get('mobile')}

Your complaint has been registered and will be processed soon. Please save your Complaint ID for future reference."""
            
            keyboard = [[InlineKeyboardButton("ЁЯФЩ Back to Main Menu", callback_data="main_menu")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(confirmation, reply_markup=reply_markup, parse_mode='Markdown')
            
            # Clear user state
            self._clear_user_state(user_id)

    async def error_handler(self, update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Handle errors in the bot"""
        logger.error(f"[ERROR] {context.error}", exc_info=context.error)
        if update and isinstance(update, Update) and update.effective_message:
            await update.effective_message.reply_text(
                "Sorry, something went wrong. Please try again later."
            )

    def register_handlers(self):
        """Register message and callback handlers"""
        self.application.add_handler(CommandHandler("start", self.start))
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.message_handler))
        self.application.add_handler(CallbackQueryHandler(self.callback_handler))
        self.application.add_error_handler(self.error_handler)  # Add error handler
        logger.info("тЬЕ All handlers registered successfully")

    def run(self):
        """Run the bot"""
        try:
            # Create application
            self.application = Application.builder().token(self.BOT_TOKEN).build()
            
            # Add handlers
            self.application.add_handler(CommandHandler("start", self.start))
            self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.message_handler))
            self.application.add_handler(CallbackQueryHandler(self.callback_handler))
            
            # Add error handler
            self.application.add_error_handler(self.error_handler)
            
            # Start the bot
            logger.info("ЁЯЪА Starting Enhanced SmartGov Assistant Bot...")
            print("ЁЯЪА Starting Enhanced SmartGov Assistant Bot...")
            print("тЬЕ Ready to serve citizens!")
            
            # Run the bot until the user presses Ctrl-C
            self.application.run_polling(allowed_updates=Update.ALL_TYPES)
            
        except Exception as e:
            logger.error(f"тЭМ Failed to start bot: {str(e)}")
            raise

if __name__ == "__main__":
    # Initialize and run bot
    bot = SmartGovAssistantBot()
    bot.run() 